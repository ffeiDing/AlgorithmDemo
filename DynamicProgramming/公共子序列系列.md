# 公共子序列
```c
// 如果i,j两个位置对应元素相等，要么len(i,j)+1，要么len(i-1,j)，要么len(i,j-1)
#include <iostream>
#include <iomanip>
#include <cmath>
#include <stdio.h>
#include <queue>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;

int main(){
	string a, b;
	while(cin >> a >> b){
		int a_len = a.length();
		int b_len = b.length();
		int len[210][210];
		memset(len, 0, sizeof(len));
		for (int i = 1; i <= a_len; i++){
			for (int j = 1; j <= b_len; j++){
				if (a[i-1] == b[j-1])
					len[i][j] = max(len[i-1][j-1]+1, max(len[i-1][j], len[i][j-1]));
				else
					len[i][j] = max(len[i-1][j], len[i][j-1]);
			}
		}
		cout << len[a_len][b_len] << endl;
	}
    return 0;
}

```

# Palindrome（回文）

n读入要加换行符，不然会读入字符串出错
```c
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

int n;
char a[5010];
int sum[2][5010];

int main() {
	scanf("%d\n", &n);
	memset(sum, 0, sizeof(sum));
	for (int i = 0; i < n; i++)
		scanf("%c", &a[i]);
	//cout << a[3] << endl;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (a[i] == a[n - 1 - j])
				sum[(i + 1) % 2][j + 1] = max(sum[i % 2][j] + 1, max(sum[i % 2][j + 1], sum[(i + 1) % 2][j]));
			else
				sum[(i + 1) % 2][j + 1] = max(sum[i % 2][j + 1], sum[(i + 1) % 2][j]);
			//cout << sum[(i + 1) % 2][j + 1] << endl;
		}
	}
	printf("%d\n", n - sum[n%2][n]);
	return 0;
}
```
