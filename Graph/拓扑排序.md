# 拓扑排序
```c
#include <iostream>
#include <iomanip>
#include <cmath>
#include <map>
#include <cstring>
using namespace std;

struct Node{
	int leaf[110];
	int in;
	int out;
};
Node node[110];
int vis[110];
int n, m;

int main(){
	cin >> n >> m;
	memset(vis, 0, sizeof(vis));
	for (int i = 1; i <= n; i++){
		node[i].in = 0;
		node[i].out = 0;
	}
	for (int i = 0; i < m; i++){
		int a, b;
		cin >> a >> b;
		node[a].leaf[node[a].out] = b;
		node[a].out++;
		node[b].in++;
	}
	int count = 0;
	int flag = 0;
	while(count < n){
		for (int i = 1; i <= n; i++){
			if (vis[i] == 0 && node[i].in == 0){
				if (flag == 1)
					cout << " ";
				else
					flag = 1;
				cout << "v" << i;
				for (int j = 0; j < node[i].out; j++){
					node[node[i].leaf[j]].in--;
				}
				vis[i] = 1;
				count++;
				break;
			}
		}
	}
	cout << endl;
	return 0;
}
```

# All Discs Considered（变型）
```c
#include <iostream>
#include <iomanip>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

int n, n1, n2, m;
int a[100001], b[100001];
queue<int> qu1, qu2;
vector<vector<int> > adj;

int main(){
	while(cin >> n1 >> n2 >> m){
		if (n1 == 0 && n2 == 0 && m == 0) break;
		n = n1+n2+1;
		adj.assign(n, vector<int>());
		memset(a, 0, sizeof(a));
		memset(b, 0, sizeof(b));
		while(m--){
			int x, y;
			cin >> x >> y;
			adj[y].push_back(x);
			a[x]++;
			b[x]++;
		}
		int sum1 = 2;
		int sum2 = 2;
		int flag = 0;
		int start = 0;
		for (int i = 1; i <= n1+n2; i++){
			if (a[i] == 0){
				if (i <= n1)
					qu1.push(i);
				else
					qu2.push(i);
			}
		}
		while(!qu1.empty() || !qu2.empty()){
			while (!qu1.empty()){
				if (flag == 0 && start != 0) sum1++;
				start = 1;
				flag = 1;
				int temp = qu1.front();
				//cout << temp << endl;
				qu1.pop();
				for (int i = 0; i < adj[temp].size(); i++){
					a[adj[temp][i]]--;
					if (a[adj[temp][i]] == 0){
						if (adj[temp][i] <= n1)
							qu1.push(adj[temp][i]);
						else
							qu2.push(adj[temp][i]);
					}
				}
			}
			flag = 0;
			while (!qu2.empty()){
				if (flag == 0 && start != 0) sum1++;
				start = 1;
				flag = 1;
				int temp = qu2.front();
				//cout << temp << endl;
				qu2.pop();
				for (int i = 0; i < adj[temp].size(); i++){
					a[adj[temp][i]]--;
					if (a[adj[temp][i]] == 0){
						if (adj[temp][i] <= n1)
							qu1.push(adj[temp][i]);
						else
							qu2.push(adj[temp][i]);
					}
				}
			}
			flag = 0;
		}
		//cout << sum1 << endl;
		flag = 0;
		start = 0;
		for (int i = 1; i <= n1+n2; i++){
			if (b[i] == 0){
				if (i <= n1)
					qu1.push(i);
				else
					qu2.push(i);
			}
		}
		while(!qu1.empty() || !qu2.empty()){
			while (!qu2.empty()){
				if (flag == 0 && start != 0) sum2++;
				flag = 1;
				start = 1;
				int temp = qu2.front();
				//cout << temp << " " << sum2 << endl;
				qu2.pop();
				for (int i = 0; i < adj[temp].size(); i++){
					b[adj[temp][i]]--;
					if (b[adj[temp][i]] == 0){
						if (adj[temp][i] <= n1)
							qu1.push(adj[temp][i]);
						else
							qu2.push(adj[temp][i]);
					}
				}
			}
			flag = 0;
			while (!qu1.empty()){
				if (flag == 0 && start != 0) sum2++;
				flag = 1;
				start = 1;
				int temp = qu1.front();
				//cout << temp << " " << sum2 << endl;
				qu1.pop();
				for (int i = 0; i < adj[temp].size(); i++){
					b[adj[temp][i]]--;
					if (b[adj[temp][i]] == 0){
						if (adj[temp][i] <= n1)
							qu1.push(adj[temp][i]);
						else
							qu2.push(adj[temp][i]);
					}
				}
			}
			flag = 0;
		}
		//cout << sum2 << endl;
		cout << min(sum1, sum2) << endl;
	}
	return 0;
}
```
